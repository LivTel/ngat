package ngat.net;

import java.lang.*;
import java.io.*;
import java.net.*;

import ngat.message.base.*;
import ngat.util.logging.*;

/**
 * The TCPClientConnectionThreadMA extends thread. It implements the generic ISS instrument command protocol.
 * This class extends the protocol by allowing multiple acknowledge messages to be returned from the
 * client to the server. This is needed when the server does not have sufficient information to
 * calculate an acknowledge time for the total operation of a command.
 * @author Chris Mottram
 * @version $Revision$
 */
public class TCPClientConnectionThreadMA extends Thread
{
  /**
   * Revision Control System id string, showing the version of the Class.
   */
  public final static String RCSID = new String("$Id$");
  /**
   * Default buffer size for input and output buffers.
   */
  public final static int DEFAULT_BUFFER_SIZE = 2048;
  /**
   * Constant defining the log level to send for error messages generated by instances of this class.
   */
  public final static int LOG_LEVEL_ERROR = 1;
  /**
   * The address the thread is communicating to.
   */
  protected InetAddress address = null;
  /**
   * The port number the thread is communicating to.
   */
  protected int portNumber = 0;
  /**
   * The socket the thread is communicating over.
   */
  protected Socket socket = null;
  /**
   * The name of the thread.
   */
  protected String name = null;
  /**
   * The object input stream to get reply objects from.
   */
  protected ObjectInputStream inputStream = null;
  /**
   * The object output stream to send commands to.
   */
  protected ObjectOutputStream outputStream = null;
  /**
   * The size of buffer to pass into BufferedInput/OutputStream for buffering.
   */
  protected int inputOutputBufferSize = DEFAULT_BUFFER_SIZE;
  /**
   * The stream to report errors on.
   */
  protected PrintWriter errorStream = null;
  /**
   * The logger to report errors to.
   */
  protected Logger logger = null;
  /**
   * The Command message sent from the client.
   */
  protected COMMAND command = null;
  /**
   * A reply message received from the server.
   */
  protected MESSAGE replyMessage = null;
  /**
   * The last acknoeldge message received from the server.
   */
  protected ACK acknowledge = null;
  /**
   * The done message returned to the client.
   */
  protected COMMAND_DONE done = null;

  /**
   * Constructor of the thread. 
   * @param address The address of the socket to communicate to.
   * @param portNumber The port number to communicate to.
   * @param c The command to communicate.
   * @see #command
   * @see #address
   * @see #portNumber
   * @see #name
   * @see #logger
   */
  public TCPClientConnectionThreadMA(InetAddress address,int portNumber,COMMAND c)
  {
    super();
    command = c;
    this.address = address;
    this.portNumber = portNumber;
    name = new String(this.getClass().getName());
    setName(name);
    logger = LogManager.getLogger(this);
  }

  /**
   * Routine to set this threads buffering for input/output operations over the socket connection.
   * The default buffer size is DEFAULT_BUFFER_SIZE. This method should be called before the
   * thread is started, where the buffer is allocated.
   * @param size The size to set the BufferedInput/OutputStream buffer size to. This should
   * 	be a positive integer.
   * @see #inputOutputBufferSize
   * @see #DEFAULT_BUFFER_SIZE
   */
  public void setIOBufferSize(int size)
  {
    if(size > -1)
      inputOutputBufferSize = size;
  }

  /**
   * The run method, which implements the ISS Generic Instrument Command Protocol. This consists of:
   * <dl>
   * <dt><a href="#sendCommand">sendCommand</a></dt>
   *	<dd>Send the COMMAND object from the client via the socket.</dd>
   * <dt><a href="#getReplyFromServer">getAcknowledgeFromServer</a></dt> 
   * 	<dd>Get a reply message back to the client. This is either an acknowledgement or a done message.</dd>
   * <dt><a href="#processAcknowledge">processAcknowledge</a></dt> 
   * 	<dd>Do anything relating to getting the acknowledge.</dd>
   * <dt><a href="#processDone">processDone</a></dt> 
   * 	<dd>Do anything relating to getting the done message.</dd>
   * <dt><a href="#close">close</a></dt> 
   * 	<dd>Close the clients socket.</dd>
   * </dl>
   * The following methods should be overridden in subclasses:
   * <ul>
   * <li><a href="#processAcknowledge">processAcknowledge</a></li>
   * <li><a href="#processDone">processDone</a></li>
   * </ul>
   * @see #sendCommand
   * @see #getReplyFromServer
   * @see #processAcknowledge
   * @see #processDone
   * @see #close
   */
  public void run()
  {
    boolean finished = false;

    // test command and rename thread
    if(command == null)
    {
      processError(name+":run:command was null");
      return;
    }
    name = new String(this.getClass().getName()+
		      ":command:"+command.getClass().getName());
    setName(name);
    try
    {
      // try opening socket
      socket = new Socket(address,portNumber);
      // rename thread
      name = new String(this.getClass().getName()+
			":command:"+command.getClass().getName()+
			":remote:"+socket.getInetAddress().toString()+":"+socket.getPort()+
			":local:"+socket.getLocalAddress().toString()+":"+socket.getLocalPort());
      setName(name);
      // attempt to get object input/output streams.
      getOutputStream();
      getInputStream();
      // try to send command to client
      sendCommand();
      // the the timout for the first reply to be received.
      socket.setSoTimeout(TCPConstants.getAckTimeOut());
      // get a reply message 
      finished = false;
      while(!finished)
      {
	getReplyFromServer();
	if(replyMessage instanceof ACK)
	{
	  acknowledge = (ACK)replyMessage;
	  // do something with the acknowledge command.
	  try
	  {
	    processAcknowledge();
	  }
	  catch(Exception e)
	  {
	    processError(name+":run:processAcknowledge:",e);
	  }
	  // reset the timeout until the next reply must be received.
	  socket.setSoTimeout(acknowledge.getTimeToComplete());
	}
	if(replyMessage instanceof COMMAND_DONE)
	{
	  done = (COMMAND_DONE)replyMessage;
	  // do something with the done command
	  try
	  {
	    processDone();
	  }
	  catch(Exception e)
	  {
	    processError(name+":run:processDone:",e);
	  }
	  // the protocol has finished - come out of the loop
	  finished = true;
	}
      }
      // close the streams etc.
      close();
    }
    catch(IOException e)
    {
      processError(name+":run:",e);
    }
    catch(ClassNotFoundException e)
    {
      processError(name+":run:",e);
    }
  }

  /**
   * Opens up the Object Output stream <a href="#outputStream">outputStream</a> from Socket 
   * <a href="#socket">socket</a> so that we can send 
   * objects to the server. If the socket is null or an IOException occurs the outputStream
   * is null. This method should not be overridden.
   * @exception IOException If the ObjectOutputStream constructor fails an IOException occurs.
   * @see #run
   */
  protected final void getOutputStream() throws IOException
  {
    outputStream = new ObjectOutputStream(new BufferedOutputStream(socket.getOutputStream(),
								   inputOutputBufferSize));
    outputStream.flush();
  }

  /**
   * Opens up the Object Input stream <a href="#inputStream">inputStream</a> from Socket 
   * <a href="#socket">socket</a> so that we can receive 
   * objects from the server. If the socket is null or an IOException occurs the inputStream
   * is null. This method should not be overridden.
   * @exception IOException If the ObjectInputStream constructor fails an IOException occurs.
   * @see #run
   */
  protected final void getInputStream() throws IOException
  {
    inputStream = new ObjectInputStream(new BufferedInputStream(socket.getInputStream(),
								inputOutputBufferSize));
  };

  /**
   * This routine tries to send the <a href="#command">command</a> to the server.
   * If the <a href="#outputStream">outputStream</a> is null or an exception occurs the routine fails.
   * @exception IOException If writeObject fails an IOException occurs.
   * @see #command
   * @see #run
   */
  protected final void sendCommand() throws IOException
  {
    outputStream.writeObject(command);
    outputStream.flush();
  }

  /**
   * This routine gets a reply message  back from the server to tell the client the command has been received.
   * @exception IOException If readObject fails an IOException occurs.
   * @exception ClassNotFoundException If readObject cannot find the read object an ClassNotFoundException 
   * 	occurs.
   * @see #replyMessage
   * @see #run
   */
  protected final void getReplyFromServer() throws IOException,ClassNotFoundException
  {
    replyMessage = (MESSAGE)(inputStream.readObject());
  }

  /**
   * This routine processes the acknowledge object returned by the server. 
   * This method should be overridden in subclasses.
   * @see #acknowledge
   * @see #run
   */
  protected void processAcknowledge()
  {
    if(acknowledge == null)
      return;
  }

  /**
   * This routine processes the done object returned by the server. 
   * This method should be overridden in subclasses.
   * @see #done
   * @see #run
   */
  protected void processDone()
  {
    if(done == null)
      return;
  }

  /**
   * Default method for processing an error message generated during the running of this thread.
   * This writes the errorString to the errorStream. If the logger has been created,
   * it logs the error with level LOG_LEVEL_ERROR.
   * This method can be over-written by sub-classes to send the errorString to an alternative 
   * location.
   * @param errorString The error string generated.
   * @see #LOG_LEVEL_ERROR
   * @see #errorStream
   * @see #logger
   */
  protected void processError(String errorString)
  {
    if(errorStream != null)
    {
      errorStream.println(errorString);
    }
    if(logger != null)
      logger.log(LOG_LEVEL_ERROR,errorString);
  }

  /**
   * Method for processing an error message generated during the running of this thread.
   * This writes the errorString to the errorStream, if the errorStream is non-null.
   * If the logger has been created, it logs the error with level LOG_LEVEL_ERROR.
   * The exception parameter has it's stack trace logged as well.
   * This method can be over-written by sub-classes to send the errorString to an alternative 
   * location.
   * This method sets the error field to true, to indicate an error has occured.
   * @param errorString The error string generated.
   * @param exception The exception that was thrown to cause this error.
   * @see #LOG_LEVEL_ERROR
   * @see #errorStream
   * @see #logger
   */
  protected void processError(String errorString,Exception exception)
  {
    if(errorStream != null)
    {
      errorStream.println(errorString);
      exception.printStackTrace(errorStream);
    }
    if(logger != null)
    {
      logger.log(LOG_LEVEL_ERROR,errorString,exception);
      logger.dumpStack(LOG_LEVEL_ERROR,exception);
    }
  }

  /**
   * This routine closes the streams down to complete the operation of the thread.
   * @exception IOException If close fails an IOException occurs.
   * @see #run
   */
  protected final void close() throws IOException
  {
    inputStream.close();
    outputStream.flush();
    outputStream.close();
    inputStream = null;
    outputStream = null;
    socket.close();
  }

  /**
   * Routine to return the command the thread is trying to send to the server.
   * @return The command.
   */
  public COMMAND getCommand()
  {
    return command;
  }

  /**
   * Routine to return the last acknowledge message the server sent in reply to the command, or null
   * if the server hasn't returned an acknowledge yet.
   * @return The done message.
   */
  public ACK getAcknowledge()
  {
    return acknowledge;
  }

  /**
   * Routine to return the done message the server sent in reply to the command, or null
   * if the server hasn't returned a message yet.
   * @return The done message.
   */
  public COMMAND_DONE getDone()
  {
    return done;
  }

  /**
   * Routine to set the error stream to something other than it's default value.
   * @param errStream The stream to set the error stream to.
   */
  public void setErrorStream(PrintWriter errStream)
  {
    errorStream = errStream;
  }
};
// $Log: not supported by cvs2svn $
// Revision 0.6  2001/07/11 10:49:53  cjm
// Error handling now uses a logger.
//
// Revision 0.5  2001/03/27 10:48:23  cjm
// Added error logger.
//
// Revision 0.4  1999/12/03 11:44:55  cjm
// Added processError method to improve error handling.
//
// Revision 0.3  1999/11/19 16:28:42  cjm
// Changed so that processAcknowledge and processDone catch Exceptions inside of them-
// they can never fail and stop the thread.
//
// Revision 0.2  1999/06/10 08:47:11  dev
// errorStream: from PrintStream to PrintWriter (deprecation).
//
// Revision 0.1  1999/06/02 15:17:59  dev
// initial revision
//
