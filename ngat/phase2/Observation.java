package ngat.phase2;

import ngat.astrometry.*;
import ngat.phase2.nonpersist.*;
import ngat.phase2.util.*;
import ngat.util.logging.*;

import com.odi.*;
import com.odi.util.*;

import java.lang.reflect.*;
import java.util.*;
import java.io.*;


// Generated by O3J 


public class Observation extends DBObject implements Serializable {
    
    // Variables.

    private transient boolean logging;

    /**  number of millis for the exposure. */
    protected float exposeTime;

    /**  indicator of whether the exposure time should be corrected for conditions. */
    protected boolean conditionalExposure;
    
    /**  number of (MULTRUN) exposures to take. */
    protected int numRuns;
    
    /**  filepath (or URL) containing the data for this Observation. */
    protected String dataLocation;
    
    /**  indicator of whether this obs has an associated  mosaic array. */
    protected boolean mosaicArray;
    
    /**  indicator of whether this obs has an associated  mosaic cross. */
    protected boolean mosaicCross;
    
    /**  gap between mosaic RA offsets (rads). */
    protected double mosaicRAOffset;
    
    /**  gap between mosaic Dec offsets (rads). */
    protected double mosaicDecOffset;
    
    /**  number of RA offsets in array/cross. */
    protected int mosaicRACells;
    
    /**  number of Dec offsets in array/cross. */
    protected int mosaicDecCells;

    /**  distance from meridian at which the source may be observed (rads). */
    protected double meridianLimit;
    
    /** determines how twilight time is to be used by this observation. */
    protected int twilightUsageMode;

    /**  reference to Telescope Configuration used. */
    protected TelescopeConfig telescopeConfig;
    
    /**  reference to Instrument Configuration used. */
    protected InstrumentConfig instrumentConfig;
    
    /**  reference to Pipeline reduction Configuration used. */
    protected PipelineConfig pipelineConfig;
    
    /**  reference to the observed Source object. */
    protected Source source;

     // Constructor.
    public Observation() {this("untitled");}
    
    public Observation(String name) {
	super(name);
    }
    
    // Accessors.   
    
    /** Sets the  number of millis for the exposure .*/
    public void setExposeTime(float in) { this.exposeTime = in;}
    
    /** Returns the  number of millis for the exposure. */
    public float getExposeTime() { return exposeTime;}
    
    /** Sets the  indicator of whether the exposure time should be corrected for conditions .*/
    public void setConditionalExposure(boolean in) { this.conditionalExposure = in;}
    
    /** True if  indicator of whether the exposure time should be corrected for conditions. */
    public boolean isConditionalExposure() { return conditionalExposure;}
    
    /** Sets the  number of (MULTRUN) exposures to take .*/
    public void setNumRuns(int in) { this.numRuns = in;}

    /** Returns the  number of (MULTRUN) exposures to take. */
    public int getNumRuns() { return numRuns;}
    
    /** Sets the  filepath (or URL) containing the data for this Observation .*/
    public void setDataLocation(String in) { this.dataLocation = in;}
    
    /** Returns the  filepath (or URL) containing the data for this Observation. */
    public String getDataLocation() { return dataLocation;}
    
    /** Sets the  indicator of whether this obs has an associated  mosaic array .*/
    public void setMosaicArray(boolean in) { this.mosaicArray = in;}
    
    /** True if  indicator of whether this obs has an associated  mosaic array. */
    public boolean isMosaicArray() { return mosaicArray;}
    
    /** Sets the  indicator of whether this obs has an associated  mosaic cross .*/
    public void setMosaicCross(boolean in) { this.mosaicCross = in;}
    
    /** True if  indicator of whether this obs has an associated  mosaic cross. */
    public boolean isMosaicCross() { return mosaicCross;}
    
    /** Sets the  gap between mosaic RA offsets (rads) .*/
    public void setMosaicRAOffset(double in) { this.mosaicRAOffset = in;}
    
    /** Returns the  gap between mosaic RA offsets (rads). */
    public double getMosaicRAOffset() { return mosaicRAOffset;}
    
    /** Sets the  gap between mosaic Dec offsets (rads) .*/
    public void setMosaicDecOffset(double in) { this.mosaicDecOffset = in;}
    
    /** Returns the  gap between mosaic Dec offsets (rads). */
    public double getMosaicDecOffset() { return mosaicDecOffset;}
    
    /** Sets the  number of RA offsets in array/cross .*/
    public void setMosaicRACells(int in) { this.mosaicRACells = in;}
    
    /** Returns the  number of RA offsets in array/cross. */
    public int getMosaicRACells() { return mosaicRACells;}
    
    /** Sets the  number of Dec offsets in array/cross .*/
    public void setMosaicDecCells(int in) { this.mosaicDecCells = in;}
    
    /** Returns the  number of Dec offsets in array/cross. */
    public int getMosaicDecCells() { return mosaicDecCells;}
    
    /** Sets the  distance from meridian at which the source may be observed (rads) .*/
    public void setMeridianLimit(double in) { this.meridianLimit = in;}
    
    /** Returns the  distance from meridian at which the source may be observed (rads). */
    public double getMeridianLimit() { return meridianLimit;}

    /** Stes the mode for twilight usage.*/
    public void setTwilightUsageMode(int mode) { twilightUsageMode = mode;}

    /** Returns the  mode for twilight usage.*/
    public int getTwilightUsageMode() { return  twilightUsageMode;}

    /** Sets the  reference to Telescope Configuration used .*/
    public void setTelescopeConfig(TelescopeConfig in) { this.telescopeConfig = in;}
    
    /** Returns the  reference to Telescope Configuration used. */
    public TelescopeConfig getTelescopeConfig() { return telescopeConfig;}
    
    /** Sets the  reference to Instrument Configuration used .*/
    public void setInstrumentConfig(InstrumentConfig in) { this.instrumentConfig = in;}
    
    /** Returns the  reference to Instrument Configuration used. */
    public InstrumentConfig getInstrumentConfig() { return instrumentConfig;}
    
    /** Sets the  reference to Pipeline reduction Configuration used .*/
    public void setPipelineConfig(PipelineConfig in) { this.pipelineConfig = in;}
    
    /** Returns the  reference to Pipeline reduction Configuration used. */
    public PipelineConfig getPipelineConfig() { return pipelineConfig;}
    
    /** Sets the  reference to the observed Source object .*/
    public void setSource(Source in) { this.source = in;}
    
    /** Returns the  reference to the observed Source object. */
    public Source getSource() { return source;}
    
    // Descendant Mutators.
    
    // NP -> P Translator.
    public Observation(NPObservation npObservation) {
	super(npObservation);
	Iterator it;
	exposeTime = npObservation.getExposeTime();
	conditionalExposure = npObservation.isConditionalExposure();
	numRuns = npObservation.getNumRuns();
	dataLocation = npObservation.getDataLocation();
	mosaicArray = npObservation.isMosaicArray();
	mosaicCross = npObservation.isMosaicCross();
	mosaicRAOffset = npObservation.getMosaicRAOffset();
	mosaicDecOffset = npObservation.getMosaicDecOffset();
	mosaicRACells = npObservation.getMosaicRACells();
	mosaicDecCells = npObservation.getMosaicDecCells();
	meridianLimit = npObservation.getMeridianLimit();
	twilightUsageMode = npObservation.getTwilightUsageMode();
	
    } // end (NP -> P Translator).
     
    // P -> NP Translator.   
    public void stuff(NPObservation npObservation) {
	super.stuff(npObservation);
	Iterator it;
	npObservation.setExposeTime(getExposeTime());
	npObservation.setConditionalExposure(isConditionalExposure());
	npObservation.setNumRuns(getNumRuns());
	npObservation.setDataLocation(getDataLocation());
	npObservation.setMosaicArray(isMosaicArray());
	npObservation.setMosaicCross(isMosaicCross());
	npObservation.setMosaicRAOffset(getMosaicRAOffset());
	npObservation.setMosaicDecOffset(getMosaicDecOffset());
	npObservation.setMosaicRACells(getMosaicRACells());
	npObservation.setMosaicDecCells(getMosaicDecCells());
	npObservation.setMeridianLimit(getMeridianLimit());	
	npObservation.setTwilightUsageMode(getTwilightUsageMode());
    } // end (P -> NP Translator).
    
    // P -> NP Translator.   
    public NPDBObject makeNP() {
	NPObservation npObservation = new NPObservation();
	stuff(npObservation);
	return npObservation;
    } // end (makeNp).     
    
    /**
     * Observation schedule scoring methods. Handcoded.
     */    
    public float getScore(double execTime) {
	Logger logger = LogManager.getLogger("SCHEDULE");
	
	// Implement Observation Level efficiency weighting functions.
	// ----------------------------------------------------------
	float score = 0.0f;
	Position target = getSource().getPosition();
	double low = 0.34906585; // 20 degs

	logger.log(1, "Observation: "+getName()+
		   "\nSource: RA: "+Position.toHMSString(target.getRA())+
		   " Dec: "+Position.toDMSString(target.getDec())+
		   "\nAlt: "+Math.toDegrees(target.getAltitude())+
		   " Az: "+Math.toDegrees(target.getAzimuth())+
		   "\nHA: "+Position.toHMSString(target.getHA())+
		   " Transits at: "+Math.toDegrees(target.getTransitHeight()));
	if (target.isRisen(low)) logger.log(1, "Star is ABOVE dome limit.");
	if (target.isSet(low))   logger.log(1, "Star is BELOW dome limit.");
	if (target.isRising())   logger.log(1, "Star is RISING.");
	if (target.isSetting())  logger.log(1, "Star is SETTING.");
	
	if (!target.neverRises(low)) {
	    logger.log(1, "Star rises: "+Position.toHMSString(target.getRiseTime()));
	} else {
	    logger.log(1, "Star NEVER RISES.");
	}
	
	if (!target.neverSets(low)) {
	    logger.log(1, "Star  sets: "+Position.toHMSString(target.getSetTime()));
	} else {
	    logger.log(1, "Star NEVER SETS.");
	}

	logger.log(1, "Twilight usage: "+twilightUsageMode);
	
	// Check sunrise/set
	Position sun = Astrometry.getSolarPosition();
	
	logger.log(1, "Sun:   RA: "+Position.toHMSString(sun.getRA())+
		   " Dec: "+Position.toDMSString(sun.getDec())+
		   "\nAlt: "+Math.toDegrees(sun.getAltitude())+
		   " Az: "+Math.toDegrees(sun.getAzimuth())+
		   "        HA: "+Position.toHMSString(sun.getHA())+
		   " transits at: "+Math.toDegrees(sun.getTransitHeight()));
	if (sun.isRisen()) {
	    logger.log(1, "sun is ABOVE Horizon."+
		       "Time left till sunset: "+
		       Position.toHMSString(sun.getUpTimeMillis()/13750987.08)+
		       "End of evening twilight: "+
		       Position.toHMSString(sun.getUpTimeMillis(-Math.toRadians(18.0))/13750987.08));
	}
	
	if (sun.isSet()) {
	    logger.log(1, "Sun is BELOW Horizon.");
	    if (sun.isRisen(-Math.toRadians(18.0))) {
		if (sun.isSetting()) {
		    logger.log(1, "EVENING TWILIGHT TIME"+
			       "Time till end of evening twilight: "+
			       Position.toHMSString(sun.getUpTimeMillis(-Math.toRadians(18.0))/13750987.08));
		} else if
		    (sun.isRising()) {
		    logger.log(1, "MORNING TWILIGHT TIME"+
			       "Time till end of morning twilight: "+
			       Position.toHMSString(sun.getDownTimeMillis(-Math.toRadians(18.0))/13750987.08));
		} 
	    }
	    logger.log(1, "Time left till sunrise: "+
		       Position.toHMSString(sun.getDownTimeMillis()/13750987.08));
	   
	}
	if (sun.isRising()) logger.log(1, "Sun is RISING.");
	if (sun.isSetting()) logger.log(1, "Sun is SETTING.");
	

	// 1. Height function.         
	WeightingParameters heightParams = Scheduling.getHeightFnParams(); 
	
	double ht = target.getAltitude();
	
	score += heightParams.evaluate(ht);
	logger.log(1, "..Scores:  HEIGHT: "+heightParams.evaluate(ht));
	// OR Scheduling.calculateHeightFn(ht);
	
	// 2. Transit Height function.        
	WeightingParameters transitParams = Scheduling.getTransitFnParams(); 
	
	double th = target.getAltitude()/target.getTransitHeight();
	
	score += transitParams.evaluate(th);
	logger.log(1, "..Scores: TRANSIT: "+transitParams.evaluate(th));
	// OR Scheduling.calculateTransitFn(th);
	
	// 3. Lunar angular distance.
	
	// 4. Meridian limits.
	
	// 5. Twilight. I,R,Z band and PUST.
	logger.log(1, "..Scores: TOTAL: "+score);
	
	return score;
    }
    
    
    public boolean getAllow(double execTime) {
	Logger logger = LogManager.getLogger("SCHEDULE");

	// Implement Veto functions.	
	boolean allow = true;
	Position target = getSource().getPosition();

	// 1. Height veto function.   
	WeightingParameters heightParams = Scheduling.getHeightFnParams();          
	double ht = target.getAltitude();
	
	allow &= heightParams.inRange(ht);
	logger.log(1, "..Allow:   HEIGHT: "+heightParams.inRange(ht))
;
	// 2. Transit veto function.  (do we need this!)   
	WeightingParameters transitParams = Scheduling.getTransitFnParams();          
	double th = target.getAltitude()/target.getTransitHeight();
	 
	allow &= transitParams.inRange(ht);
	logger.log(1, "..Allow:  TRANSIT: "+transitParams.inRange(th));
	
	// 3. Lunar angular distance veto function.
	// ##For now this is a sharp cutoff at 2.5 degrees.
	
	//allow &= lunarParams.inRange(lunarDistance);
	
	Position moon = Astrometry.getLunarPosition();
	
	logger.log(1, "Moon:   RA: "+Position.toHMSString(moon.getRA())+
		   " Dec: "+Position.toDMSString(moon.getDec())+
		   "\nAlt: "+Math.toDegrees(moon.getAltitude())+
		   " Az: "+Math.toDegrees(moon.getAzimuth())+
		   "\nHA: "+Position.toHMSString(moon.getHA())+
		   " Transits at: "+Math.toDegrees(moon.getTransitHeight()));
	if (moon.isRisen()) {
	    logger.log(1, "Moon is ABOVE Horizon.");
	    logger.log(1, "Time left till DARK: "+(moon.getUpTimeMillis()/1000.0)+"secs");
	}

	if (moon.isSet()) {
	    logger.log(1, "Moon is BELOW Horizon."+
		       "Time left till BRIGHT: "+(moon.getDownTimeMillis()/1000.0)+"secs");
	}
	if (moon.isRising()) logger.log(1, "Moon is RISING.");
	if (moon.isSetting()) logger.log(1, "Moon is SETTING.");
	
	double lunarAngularDistance = target.getAngularDistance(moon);
	logger.log(1,  "Lunar angle distance: "+Position.toDMSString(lunarAngularDistance));
	if (lunarAngularDistance < 0.0436) {
	    logger.log(1, "..Allow: LUNAR DIST: false");
	    allow = false;
	}
	
	// 4. Meridian veto.
	long meridianDistance = (long)(target.getHA()*43200000.0/Math.PI);// in msecs
	logger.log(1, "Meridian distance: "+meridianDistance+" msecs");
	if (meridianDistance > 43200000) meridianDistance = 86400000 - meridianDistance;
	if (meridianLimit > 1 &&  meridianDistance > meridianLimit) allow = false;
	logger.log(1, "..Allow: MERIDIAN: "+(!( meridianLimit > 1 &&  meridianDistance > meridianLimit)));
	
	
	
	// 5. 
	
	// 6. Visible over full executionTime veto.
	// source must be above horizon for the full exectime.
	logger.log(1, "Time left above dome limits: "+(target.getUpTimeMillis()/1000.0)+"secs"+
		   " Time needed for execution:   "+(execTime/1000.0)+"secs");
	if (target.getUpTimeMillis() < execTime) allow = false;
	logger.log(1, "..Allow:  HORIZON: "+(target.getUpTimeMillis() > execTime));
	return allow;
    }

} // end class def [Observation].
