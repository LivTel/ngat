package ngat.phase2;
import ngat.phase2.nonpersist.*;

import com.odi.*;
import com.odi.util.*;
import java.lang.reflect.*;
import java.util.*;
import java.io.*;


// Generated by O3J 


public class Proposal extends DBObject implements Serializable {

     // Variables.



     /**  fraction of time used so far during BrightSky/ExcellentSeeing conditions. */
     protected float usedFraction_BX;

     /**  fraction of time used so far during BrightSky/AverageSeeing conditions. */
     protected float usedFraction_BA;

     /**  fraction of time used so far during BrightSky/PoorSeeing conditions. */
     protected float usedFraction_BP;

     /**  fraction of time used so far during DarkSky/ExcellentSeeing conditions. */
     protected float usedFraction_DX;

     /**  fraction of time used so far during DarkSky/AverageSeeing conditions. */
     protected float usedFraction_DA;

     /**  fraction of time used so far during DarkSky/PoorSeeing conditions. */
     protected float usedFraction_DP;


     /**  fraction of time allocated to BrightSky/ExcellentSeeing conditions. */
     protected float allocatedFraction_BX;

     /**  fraction of time allocated to BrightSky/AverageSeeing conditions. */
     protected float allocatedFraction_BA;

     /**  fraction of time allocated to BrightSky/PoorSeeing conditions. */
     protected float allocatedFraction_BP;

     /**  fraction of time allocated to DarkSky/ExcellentSeeing conditions. */
     protected float allocatedFraction_DX;

     /**  fraction of time allocated to DarkSky/AverageSeeing conditions. */
     protected float allocatedFraction_DA;

     /**  fraction of time allocated to DarkSky/PoorSeeing conditions. */
     protected float allocatedFraction_DP;


     /**  total time allocated to this Proposal ### long. */
     protected float allocatedTime;

     /**  total time used so far by this Proposal ### long. */
     protected float usedTime;


     /**  bitfield to indicate which instruments can be used. */
     protected int instrumentsAllowed;

     /**  date after which this Proposal can be scheduled. */
     protected long activationDate;

     /**  date after which the Proposal cannot be scheduled. */
     protected long expiryDate;

     /** no comment. */
     protected String pustAbstract;

     /** no comment. */
     protected String scienceAbstract;


     /**  records date/time of last (user) update (ie. unlock). */
     protected long lastUnLocked;

     /**  records date/time of last (user) lock on this Proposal. */
     protected long lastLocked;

     /**  records the uid of the last user to edit this Proposal. */
     protected String lastEditor;

    /** records the registration Id of the last user/tool instance to edit this Proposal. */
    protected long lastRegId;

     /** indicates whether this Proposal has been exported (for further editing by another user). */
     protected boolean exported;
 
    protected OSHashMap groups;
    protected OSHashMap telescopeConfigs;
    protected OSHashMap instrumentConfigs;
    protected OSHashMap pipelineConfigs;
    protected OSHashMap sources;

     // Constructor.

     public Proposal() {this("untitled");}

     public Proposal(String name) {
          super(name);
          groups = new OSHashMap();
          telescopeConfigs = new OSHashMap();
          instrumentConfigs = new OSHashMap();
          pipelineConfigs = new OSHashMap();
          sources = new OSHashMap();
     }

     // Accessors.



     /** Sets the  fraction of time used so far during BrightSky/ExcellentSeeing conditions .*/
     public void setUsedFraction_BX(float in) { this.usedFraction_BX = in;}

     /** Returns the  fraction of time used so far during BrightSky/ExcellentSeeing conditions. */
     public float getUsedFraction_BX() { return usedFraction_BX;}

     /** Sets the  fraction of time used so far during BrightSky/AverageSeeing conditions .*/
     public void setUsedFraction_BA(float in) { this.usedFraction_BA = in;}

     /** Returns the  fraction of time used so far during BrightSky/AverageSeeing conditions. */
     public float getUsedFraction_BA() { return usedFraction_BA;}

     /** Sets the  fraction of time used so far during BrightSky/PoorSeeing conditions .*/
     public void setUsedFraction_BP(float in) { this.usedFraction_BP = in;}

     /** Returns the  fraction of time used so far during BrightSky/PoorSeeing conditions. */
     public float getUsedFraction_BP() { return usedFraction_BP;}

     /** Sets the  fraction of time used so far during DarkSky/ExcellentSeeing conditions .*/
     public void setUsedFraction_DX(float in) { this.usedFraction_DX = in;}

     /** Returns the  fraction of time used so far during DarkSky/ExcellentSeeing conditions. */
     public float getUsedFraction_DX() { return usedFraction_DX;}

     /** Sets the  fraction of time used so far during DarkSky/AverageSeeing conditions .*/
     public void setUsedFraction_DA(float in) { this.usedFraction_DA = in;}

     /** Returns the  fraction of time used so far during DarkSky/AverageSeeing conditions. */
     public float getUsedFraction_DA() { return usedFraction_DA;}

     /** Sets the  fraction of time used so far during DarkSky/PoorSeeing conditions .*/
     public void setUsedFraction_DP(float in) { this.usedFraction_DP = in;}

     /** Returns the  fraction of time used so far during DarkSky/PoorSeeing conditions. */
     public float getUsedFraction_DP() { return usedFraction_DP;}

     /** Sets the  fraction of time allocated to BrightSky/ExcellentSeeing conditions .*/
     public void setAllocatedFraction_BX(float in) { this.allocatedFraction_BX = in;}

     /** Returns the  fraction of time allocated to BrightSky/ExcellentSeeing conditions. */
     public float getAllocatedFraction_BX() { return allocatedFraction_BX;}

     /** Sets the  fraction of time allocated to BrightSky/AverageSeeing conditions .*/
     public void setAllocatedFraction_BA(float in) { this.allocatedFraction_BA = in;}

     /** Returns the  fraction of time allocated to BrightSky/AverageSeeing conditions. */
     public float getAllocatedFraction_BA() { return allocatedFraction_BA;}

     /** Sets the  fraction of time allocated to BrightSky/PoorSeeing conditions .*/
     public void setAllocatedFraction_BP(float in) { this.allocatedFraction_BP = in;}

     /** Returns the  fraction of time allocated to BrightSky/PoorSeeing conditions. */
     public float getAllocatedFraction_BP() { return allocatedFraction_BP;}

     /** Sets the  fraction of time allocated to DarkSky/ExcellentSeeing conditions .*/
     public void setAllocatedFraction_DX(float in) { this.allocatedFraction_DX = in;}

     /** Returns the  fraction of time allocated to DarkSky/ExcellentSeeing conditions. */
     public float getAllocatedFraction_DX() { return allocatedFraction_DX;}

     /** Sets the  fraction of time allocated to DarkSky/AverageSeeing conditions .*/
     public void setAllocatedFraction_DA(float in) { this.allocatedFraction_DA = in;}

     /** Returns the  fraction of time allocated to DarkSky/AverageSeeing conditions. */
     public float getAllocatedFraction_DA() { return allocatedFraction_DA;}

     /** Sets the  fraction of time allocated to DarkSky/PoorSeeing conditions .*/
     public void setAllocatedFraction_DP(float in) { this.allocatedFraction_DP = in;}

     /** Returns the  fraction of time allocated to DarkSky/PoorSeeing conditions. */
     public float getAllocatedFraction_DP() { return allocatedFraction_DP;}

     /** Sets the  total time allocated to this Proposal ### long .*/
     public void setAllocatedTime(float in) { this.allocatedTime = in;}

     /** Returns the  total time allocated to this Proposal ### long. */
     public float getAllocatedTime() { return allocatedTime;}

     /** Sets the  total time used so far by this Proposal ### long .*/
     public void setUsedTime(float in) { this.usedTime = in;}

     /** Returns the  total time used so far by this Proposal ### long. */
     public float getUsedTime() { return usedTime;}

     /** Sets the  bitfield to indicate which instruments can be used .*/
     public void setInstrumentsAllowed(int in) { this.instrumentsAllowed = in;}

     /** Returns the  bitfield to indicate which instruments can be used. */
     public int getInstrumentsAllowed() { return instrumentsAllowed;}

     /** Sets the  date after which this Proposal can be scheduled .*/
     public void setActivationDate(long in) { this.activationDate = in;}

     /** Returns the  date after which this Proposal can be scheduled. */
     public long getActivationDate() { return activationDate;}

     /** Sets the  date after which the Proposal cannot be scheduled .*/
     public void setExpiryDate(long in) { this.expiryDate = in;}

     /** Returns the  date after which the Proposal cannot be scheduled. */
     public long getExpiryDate() { return expiryDate;}

     /** Sets the no comment .*/
     public void setPustAbstract(String in) { this.pustAbstract = in;}

     /** Returns the no comment. */
     public String getPustAbstract() { return pustAbstract;}

     /** Sets the no comment .*/
     public void setScienceAbstract(String in) { this.scienceAbstract = in;}

     /** Returns the no comment. */
     public String getScienceAbstract() { return scienceAbstract;}

     /** Sets the  records date/time of last (user) update (ie. unlock) .*/
     public void setLastUnLocked(long in) { this.lastUnLocked = in;}

     /** Returns the  records date/time of last (user) update (ie. unlock). */
     public long getLastUnLocked() { return lastUnLocked;}

     /** Sets the  records date/time of last (user) lock on this Proposal .*/
     public void setLastLocked(long in) { this.lastLocked = in;}

     /** Returns the  records date/time of last (user) lock on this Proposal. */
     public long getLastLocked() { return lastLocked;}

     /** Sets the  records the uid of the last user to edit this Proposal .*/
     public void setLastEditor(String in) { this.lastEditor = in;}

     /** Returns the  records the uid of the last user to edit this Proposal. */
     public String getLastEditor() { return lastEditor;}

    /** Sets the reg Id of the last user to edit this Proposal. */
    public void setLastRegId(long in) { this.lastRegId = in;}
    
    /** Returns the reg Id of the last user to edit this Proposal. */
    public long getLastRegId() { return lastRegId;}

     /** Sets the no comment .*/
     public void setExported(boolean in) { this.exported = in;}

     /** True if no comment. */
     public boolean isExported() { return exported;}

     // Descendant Mutators.


     // Group Methods.
     public void addGroup(Group group) {
          groups.put(group.getName(), group);
          group.setPath(getPath() + "/" + getName());
     }

     public void deleteGroup(Group group) {
          groups.remove(group.getName());
     }

     public void removeAllGroups() {
          groups.clear();
     }

     public Iterator listAllGroups() {
          return groups.values().iterator();
     }

     public Group findGroup(String name) {
          if (groups.containsKey(name)) return ((Group)groups.get(name));
          return null;
     }

     public OSHashMap getGroups() { return groups;}

     // TelescopeConfig Methods.
     public void addTelescopeConfig(TelescopeConfig telescopeConfig) {
          telescopeConfigs.put(telescopeConfig.getName(), telescopeConfig);
     }

     public void deleteTelescopeConfig(TelescopeConfig telescopeConfig) {
          telescopeConfigs.remove(telescopeConfig.getName());
     }

     public void removeAllTelescopeConfigs() {
          telescopeConfigs.clear();
     }

     public Iterator listAllTelescopeConfigs() {
          return telescopeConfigs.values().iterator();
     }

     public TelescopeConfig findTelescopeConfig(String name) {
          if (telescopeConfigs.containsKey(name)) return ((TelescopeConfig)telescopeConfigs.get(name));
          return null;
     }

     public OSHashMap getTelescopeConfigs() { return telescopeConfigs;}

     // InstrumentConfig Methods.
     public void addInstrumentConfig(InstrumentConfig instrumentConfig) {
          instrumentConfigs.put(instrumentConfig.getName(), instrumentConfig);
     }

     public void deleteInstrumentConfig(InstrumentConfig instrumentConfig) {
          instrumentConfigs.remove(instrumentConfig.getName());
     }

     public void removeAllInstrumentConfigs() {
          instrumentConfigs.clear();
     }

     public Iterator listAllInstrumentConfigs() {
          return instrumentConfigs.values().iterator();
     }

     public InstrumentConfig findInstrumentConfig(String name) {
          if (instrumentConfigs.containsKey(name)) return ((InstrumentConfig)instrumentConfigs.get(name));
          return null;
     }

     public OSHashMap getInstrumentConfigs() { return instrumentConfigs;}

     // PipelineConfig Methods.
     public void addPipelineConfig(PipelineConfig pipelineConfig) {
          pipelineConfigs.put(pipelineConfig.getName(), pipelineConfig);
     }

     public void deletePipelineConfig(PipelineConfig pipelineConfig) {
          pipelineConfigs.remove(pipelineConfig.getName());
     }

     public void removeAllPipelineConfigs() {
          pipelineConfigs.clear();
     }    
    
    public Iterator listAllPipelineConfigs() {
	return pipelineConfigs.values().iterator();
    }
     
    public PipelineConfig findPipelineConfig(String name) {
	if (pipelineConfigs.containsKey(name)) return ((PipelineConfig)pipelineConfigs.get(name));
	return null;
    }
     
     public OSHashMap getPipelineConfigs() { return pipelineConfigs;}
     
     // Source Methods. 
     public void addSource(Source source) {
	 sources.put(source.getName(), source);
     }

     public void deleteSource(Source source) {
          sources.remove(source.getName());
     }

     public void removeAllSources() {
          sources.clear();
     }

     public Iterator listAllSources() {
          return sources.values().iterator();
     }

     public Source findSource(String name) {
          if (sources.containsKey(name)) return ((Source)sources.get(name));
          return null;
     }

     public OSHashMap getSources() { return sources;}
     
     // NP -> P Translator.
     public Proposal(NPProposal npProposal) {
          super(npProposal);
          Iterator it;
          usedFraction_BX = npProposal.getUsedFraction_BX();
          usedFraction_BA = npProposal.getUsedFraction_BA();
          usedFraction_BP = npProposal.getUsedFraction_BP();
          usedFraction_DX = npProposal.getUsedFraction_DX();
          usedFraction_DA = npProposal.getUsedFraction_DA();
          usedFraction_DP = npProposal.getUsedFraction_DP();
          allocatedFraction_BX = npProposal.getAllocatedFraction_BX();
          allocatedFraction_BA = npProposal.getAllocatedFraction_BA();
          allocatedFraction_BP = npProposal.getAllocatedFraction_BP();
          allocatedFraction_DX = npProposal.getAllocatedFraction_DX();
          allocatedFraction_DA = npProposal.getAllocatedFraction_DA();
          allocatedFraction_DP = npProposal.getAllocatedFraction_DP();
          allocatedTime = npProposal.getAllocatedTime();
          usedTime = npProposal.getUsedTime();
          instrumentsAllowed = npProposal.getInstrumentsAllowed();
          activationDate = npProposal.getActivationDate();
          expiryDate = npProposal.getExpiryDate();
          pustAbstract = npProposal.getPustAbstract();
          scienceAbstract = npProposal.getScienceAbstract();
          lastUnLocked = npProposal.getLastUnLocked();
          lastLocked = npProposal.getLastLocked();
          lastEditor = npProposal.getLastEditor();
	  lastRegId = npProposal.getLastRegId();
          exported = npProposal.isExported();
          
          // Recursively call Daughter Translators.
          groups = new OSHashMap();
          it = npProposal.listAllNPGroups();
          while (it.hasNext()) {
               try {
                    NPGroup npGroup = (NPGroup)it.next();
                    Class npClazz = npGroup.getClass();
                    String npName = npClazz.getName();
                    int k = npName.indexOf("nonpersist.NP");
                    String pName = npName.substring(0,k).concat(npName.substring(k+13));
                    Class pClazz = Class.forName(pName);
                    Constructor pCon = pClazz.getConstructor(new Class[]{npClazz});
                    Group group = (Group)pCon.newInstance(new Object[]{npGroup});
                    addGroup(group);
               } catch (ClassNotFoundException re1){
                    System.out.println("Translation Error: "+re1);
               } catch (NoSuchMethodException re2) {
                    System.out.println("Translation Error: "+re2);
               } catch (InvocationTargetException re3) {
                    System.out.println("Translation Error: "+re3);
               } catch (IllegalAccessException re4) {
                    System.out.println("Translation Error: "+re4);
               } catch (InstantiationException re5) {
                    System.out.println("Translation Error: "+re5);
               }
          }
          telescopeConfigs = new OSHashMap();
          it = npProposal.listAllNPTelescopeConfigs();
          while (it.hasNext()) {
               try {
                    NPTelescopeConfig npTelescopeConfig = (NPTelescopeConfig)it.next();
                    Class npClazz = npTelescopeConfig.getClass();
                    String npName = npClazz.getName();
                    int k = npName.indexOf("nonpersist.NP");
                    String pName = npName.substring(0,k).concat(npName.substring(k+13));
                    Class pClazz = Class.forName(pName);
                    Constructor pCon = pClazz.getConstructor(new Class[]{npClazz});
                    TelescopeConfig telescopeConfig = (TelescopeConfig)pCon.newInstance(new Object[]{npTelescopeConfig});
                    addTelescopeConfig(telescopeConfig);
               } catch (ClassNotFoundException re1){
                    System.out.println("Translation Error: "+re1);
               } catch (NoSuchMethodException re2) {
                    System.out.println("Translation Error: "+re2);
               } catch (InvocationTargetException re3) {
                    System.out.println("Translation Error: "+re3);
               } catch (IllegalAccessException re4) {
                    System.out.println("Translation Error: "+re4);
               } catch (InstantiationException re5) {
                    System.out.println("Translation Error: "+re5);
               }
          }
          instrumentConfigs = new OSHashMap();
          it = npProposal.listAllNPInstrumentConfigs();
          while (it.hasNext()) {
               try {
                    NPInstrumentConfig npInstrumentConfig = (NPInstrumentConfig)it.next();
                    Class npClazz = npInstrumentConfig.getClass();
                    String npName = npClazz.getName();
                    int k = npName.indexOf("nonpersist.NP");
                    String pName = npName.substring(0,k).concat(npName.substring(k+13));
                    Class pClazz = Class.forName(pName);
                    Constructor pCon = pClazz.getConstructor(new Class[]{npClazz});
                    InstrumentConfig instrumentConfig = (InstrumentConfig)pCon.newInstance(new Object[]{npInstrumentConfig});
                    addInstrumentConfig(instrumentConfig);
               } catch (ClassNotFoundException re1){
                    System.out.println("Translation Error: "+re1);
               } catch (NoSuchMethodException re2) {
                    System.out.println("Translation Error: "+re2);
               } catch (InvocationTargetException re3) {
		   System.out.println("P trans.Translation Error: "+re3+re3.getTargetException());
               } catch (IllegalAccessException re4) {
                    System.out.println("Translation Error: "+re4);
               } catch (InstantiationException re5) {
                    System.out.println("Translation Error: "+re5);
               }
          }
          pipelineConfigs = new OSHashMap();
          it = npProposal.listAllNPPipelineConfigs();
          while (it.hasNext()) {
               try {
                    NPPipelineConfig npPipelineConfig = (NPPipelineConfig)it.next();
                    Class npClazz = npPipelineConfig.getClass();
                    String npName = npClazz.getName();
                    int k = npName.indexOf("nonpersist.NP");
                    String pName = npName.substring(0,k).concat(npName.substring(k+13));
                    Class pClazz = Class.forName(pName);
                    Constructor pCon = pClazz.getConstructor(new Class[]{npClazz});
                    PipelineConfig pipelineConfig = (PipelineConfig)pCon.newInstance(new Object[]{npPipelineConfig});
                    addPipelineConfig(pipelineConfig);
               } catch (ClassNotFoundException re1){
                    System.out.println("Translation Error: "+re1);
               } catch (NoSuchMethodException re2) {
                    System.out.println("Translation Error: "+re2);
               } catch (InvocationTargetException re3) {
                    System.out.println("Translation Error: "+re3);
               } catch (IllegalAccessException re4) {
                    System.out.println("Translation Error: "+re4);
               } catch (InstantiationException re5) {
                    System.out.println("Translation Error: "+re5);
               }
          }
          sources = new OSHashMap();
          it = npProposal.listAllNPSources();
          while (it.hasNext()) {
               try {
                    NPSource npSource = (NPSource)it.next();
                    Class npClazz = npSource.getClass();
                    String npName = npClazz.getName();
                    int k = npName.indexOf("nonpersist.NP");
                    String pName = npName.substring(0,k).concat(npName.substring(k+13));
                    Class pClazz = Class.forName(pName);
                    Constructor pCon = pClazz.getConstructor(new Class[]{npClazz});
                    Source source = (Source)pCon.newInstance(new Object[]{npSource});
                    addSource(source);
               } catch (ClassNotFoundException re1){
                    System.out.println("Translation Error: "+re1);
               } catch (NoSuchMethodException re2) {
                    System.out.println("Translation Error: "+re2);
               } catch (InvocationTargetException re3) {
                    System.out.println("Translation Error: "+re3);
               } catch (IllegalAccessException re4) {
                    System.out.println("Translation Error: "+re4);
               } catch (InstantiationException re5) {
                    System.out.println("Translation Error: "+re5);
               }
          }
	 
	  // Re-link Observations to tabled objects.
	  Source source = null;
	  InstrumentConfig instrumentConfig = null;
	  TelescopeConfig telescopeConfig = null;
	  PipelineConfig pipelineConfig = null;
	  Group group = null;
	  Observation observation = null;

	  NPSource npSource = null;
	  NPInstrumentConfig npInstrumentConfig = null;
	  NPTelescopeConfig npTelescopeConfig = null;
	  NPPipelineConfig npPipelineConfig = null; 
	  NPGroup npGroup = null;
	  NPObservation npObservation = null;

	  Iterator it1, it2;
	  
	  it1 = listAllGroups();
	  while (it1.hasNext()) {
	      group = (Group)it1.next();
	     
	      npGroup = npProposal.findNPGroup(group.getName());
	      if (npGroup != null) {
		  
		  it2 = group.listAllObservations();
		  while (it2.hasNext()) {
		      
		      observation = (Observation)it2.next();
		    
		      npObservation = npGroup.findNPObservation(observation.getName());

		      if (npObservation != null) {
			 
			  npSource = npObservation.getNPSource();
			  if (npSource != null) {
			      source = findSource(npSource.getName());
			      if (source != null)  observation.setSource(source);
			     
			  }

			  npInstrumentConfig = npObservation.getNPInstrumentConfig();
			  if (npInstrumentConfig != null) {
			      instrumentConfig = findInstrumentConfig(npInstrumentConfig.getName());
			      if (instrumentConfig != null) observation.setInstrumentConfig(instrumentConfig);
			      
			  }
			  
			  npTelescopeConfig = npObservation.getNPTelescopeConfig();
			  if (npTelescopeConfig != null) {
			      telescopeConfig = findTelescopeConfig(npTelescopeConfig.getName());
			      if (telescopeConfig != null) observation.setTelescopeConfig(telescopeConfig);
			     
			  }
			  
			  npPipelineConfig = npObservation.getNPPipelineConfig();
			  if (npPipelineConfig != null) {
			      pipelineConfig = findPipelineConfig(npPipelineConfig.getName());
			      if (pipelineConfig != null) observation.setPipelineConfig(pipelineConfig);
			    
			  }
		      }
		  }
	      }
	  }
	  
     } // end (NP -> P Translator).
     
     // P -> NP Translator.
     public void stuff(NPProposal npProposal) {
          super.stuff(npProposal);
          Iterator it;
          npProposal.setUsedFraction_BX(getUsedFraction_BX());
          npProposal.setUsedFraction_BA(getUsedFraction_BA());
          npProposal.setUsedFraction_BP(getUsedFraction_BP());
          npProposal.setUsedFraction_DX(getUsedFraction_DX());
          npProposal.setUsedFraction_DA(getUsedFraction_DA());
          npProposal.setUsedFraction_DP(getUsedFraction_DP());
          npProposal.setAllocatedFraction_BX(getAllocatedFraction_BX());
          npProposal.setAllocatedFraction_BA(getAllocatedFraction_BA());
          npProposal.setAllocatedFraction_BP(getAllocatedFraction_BP());
          npProposal.setAllocatedFraction_DX(getAllocatedFraction_DX());
          npProposal.setAllocatedFraction_DA(getAllocatedFraction_DA());
          npProposal.setAllocatedFraction_DP(getAllocatedFraction_DP());
          npProposal.setAllocatedTime(getAllocatedTime());
          npProposal.setUsedTime(getUsedTime());
          npProposal.setInstrumentsAllowed(getInstrumentsAllowed());
          npProposal.setActivationDate(getActivationDate());
          npProposal.setExpiryDate(getExpiryDate());
          npProposal.setPustAbstract(getPustAbstract());
          npProposal.setScienceAbstract(getScienceAbstract());
          npProposal.setLastUnLocked(getLastUnLocked());
          npProposal.setLastLocked(getLastLocked());
          npProposal.setLastEditor(getLastEditor());
	  npProposal.setLastRegId(getLastRegId());
          npProposal.setExported(isExported());
	  
	  // Translate Daughter objects.
          it = listAllGroups();
          while (it.hasNext()) {
	      npProposal.addNPGroup((NPGroup)(((Group)it.next()).makeNP()));
          }

	  // Translate attached tables.
          it = listAllTelescopeConfigs();
          while (it.hasNext()) {
               npProposal.addNPTelescopeConfig((NPTelescopeConfig)(((TelescopeConfig)it.next()).makeNP()));
          }

	  InstrumentConfig instrumentConfig = null;
          it = listAllInstrumentConfigs();
          while (it.hasNext()) {
	      instrumentConfig = (InstrumentConfig)it.next();
	      npProposal.addNPInstrumentConfig( (NPInstrumentConfig)instrumentConfig.makeNP() );
          }

          it = listAllPipelineConfigs();
          while (it.hasNext()) {
               npProposal.addNPPipelineConfig((NPPipelineConfig)(((PipelineConfig)it.next()).makeNP()));
          }

          it = listAllSources();
          while (it.hasNext()) {
               npProposal.addNPSource((NPSource)(((Source)it.next()).makeNP()));
          }

	  // Re-link Observations to tabled objects.
	  Source source = null;
 
	  TelescopeConfig telescopeConfig = null;
	  PipelineConfig pipelineConfig = null;
	  Group group = null;
	  Observation observation = null;

	  NPSource npSource = null;
	  NPInstrumentConfig npInstrumentConfig = null;
	  NPTelescopeConfig npTelescopeConfig = null;
	  NPPipelineConfig npPipelineConfig = null; 
	  NPGroup npGroup = null;
	  NPObservation npObservation = null;

	  Iterator it1, it2;

	  it1 = listAllGroups();
	  while (it1.hasNext()) {
	      group = (Group)it1.next();
	      npGroup = npProposal.findNPGroup(group.getName());
	      if (npGroup == null) break;
	      it2 = group.listAllObservations();
	      while (it2.hasNext()) {
		      
		  observation = (Observation)it2.next();
		  npObservation = npGroup.findNPObservation(observation.getName());
		  if (npObservation == null) break;
		  
		  source = observation.getSource();
		  if (source != null) {
		      npSource = npProposal.findNPSource(source.getName());
		      if (npSource != null) npObservation.setNPSource(npSource);
		  }

		  instrumentConfig = observation.getInstrumentConfig();
		  if (instrumentConfig != null) {
		      npInstrumentConfig = npProposal.findNPInstrumentConfig(instrumentConfig.getName());
		      if (npInstrumentConfig != null) npObservation.setNPInstrumentConfig(npInstrumentConfig);
		  }

		  telescopeConfig = observation.getTelescopeConfig();
		  if (telescopeConfig != null) {
		      npTelescopeConfig = npProposal.findNPTelescopeConfig(telescopeConfig.getName());
		      if (npTelescopeConfig != null) npObservation.setNPTelescopeConfig(npTelescopeConfig);
		  }

		  pipelineConfig = observation.getPipelineConfig();
		  if (pipelineConfig != null) {
		      npPipelineConfig = npProposal.findNPPipelineConfig(pipelineConfig.getName());
		      if (npPipelineConfig != null) npObservation.setNPPipelineConfig(npPipelineConfig);
		  }
	      }
	  }

     } // end (P -> NP Translator).
     
     // P -> NP Translator.
     public NPDBObject makeNP() {
          NPProposal npProposal = new NPProposal();
          stuff(npProposal);
          return npProposal;
     } // end (makeNp).

     // Lock Proposal and subtree.
     public void lock(int key) {
          setLock(key);
	  lockChildren(key);
     } // end (lock).

     // Child Update Method.
     public void updateChildren() {
          Iterator it  = listAllGroups();
          while (it.hasNext()) {
               Group group = (Group)it.next();
               group.setPath(path+"/"+name);
               group.updateChildren();
          }
     } // end (updateChildren).

     // Child Lock-Check Method.
     public boolean canLock() {
          if (isLocked()) return false;
          Iterator it  = listAllGroups();
          while (it.hasNext()) {
               Group group = (Group)it.next();
               if (!group.canLock()) return false;
          }
          return true;
     } // end (canLock).

     // Subtree Locking Method.
     public void lockChildren(int key) {
	 setLock(key);
	 Iterator it  = listAllGroups();
	 while (it.hasNext()) {
	     Group group = (Group)it.next();
	     group.lockChildren(key);
	 }	
     } // end (lockChildren).

     // Subtree Un-Locking Method.
     public void unLockChildren(int key) {
	 unLock(key);
	 Iterator it  = listAllGroups();
	 while (it.hasNext()) {
	     Group group = (Group)it.next();
	     group.unLockChildren(key);
	 }
     } // end (unLockChildren).

     // Force Un-Locking Method.
     public void forceUnLock() {
          lock = 0;
          Iterator it  = listAllGroups();
          while (it.hasNext()) {
               Group group = (Group)it.next();
               group.forceUnLock();
          }
     } // end (forceUnLock).


    /** Returns a ProposalDescriptor for this Proposal. */
    public ProposalDescriptor getDescriptor() {
	ProposalDescriptor descriptor = new ProposalDescriptor(name);
	descriptor.setPath(path);
	descriptor.setLock(lock);
	descriptor.setLastEditor(lastEditor);
	descriptor.setLastLocked(lastLocked);
	descriptor.setLastUnLocked(lastUnLocked);
	descriptor.setAllocatedTime(allocatedTime);
	descriptor.setUsedTime(usedTime);
	descriptor.setInstrumentsAllowed(instrumentsAllowed);
	descriptor.setPustAbstract(pustAbstract);
	descriptor.setScienceAbstract(scienceAbstract);
	descriptor.setActivationDate(activationDate);
	descriptor.setExported(exported);
	descriptor.setLastRegId(lastRegId);
	descriptor.setAllocatedFraction_BX(allocatedFraction_BX);
	descriptor.setAllocatedFraction_BA(allocatedFraction_BA);
	descriptor.setAllocatedFraction_BP(allocatedFraction_BP);
	descriptor.setAllocatedFraction_DX(allocatedFraction_DX);
	descriptor.setAllocatedFraction_DA(allocatedFraction_DA);
	descriptor.setAllocatedFraction_DP(allocatedFraction_DP);
	return descriptor;
    }

     // FixedGroup Method.

     public FixedGroup getNextFixedGroup() {
          FixedGroup earliest = new FixedGroup("NULL");
          // Set earliest Fixed to about Y29,688 AD !
          earliest.setFixedTime(999999999999999L);
          Iterator it = listAllGroups();
          while (it.hasNext()) {
               Group group = (Group)it.next();
               if (!group.isLocked() && !group.deleted()) {
                    FixedGroup fg = group.getNextFixedGroup();
                    if (fg != null) {
                         if (fg.getFixedTime() < earliest.getFixedTime()) {
                              earliest = fg;
                         }
                    }
               }
          }
          return earliest;
     } // end (getNextFixedGroup).

     // Scheduling Method.
    // Modified to apply the Proposal level functions before selection.
    // Added link back to this from group.
     public ScheduleDescriptor schedule() {
          ScheduleDescriptor best = new ScheduleDescriptor(null,0.0f,0);
          Iterator it = listAllGroups();
          while (it.hasNext()) {
               Group group = (Group)it.next();
               if (!group.isLocked() && !group.deleted()) {
                    ScheduleDescriptor sd = group.schedule(this, null, false);
		    sd = applyScheduling(sd);
                    if (sd.getGroup() != null) {
                         if (sd.getScore() > best.getScore()) {
                              best.setGroup(sd.getGroup());
                              best.setScore(sd.getScore());
                              best.setExecTime(sd.getExecTime());
                         }
                    }
               }
          }
          return best;
     } // end (schedule).

     // Scheduling Algorithm.

     public ScheduleDescriptor applyScheduling(ScheduleDescriptor best) {
     


          // Insert code here to apply this.object's schedule coefft.
          // will make use of attribute: [ schedCoeff ] and possibly
          // various ServerContext and TelescopeEnvironment variables.
          

          best.setScore(best.getScore()*schedCoeff);
          return best;
     


     } // end (applyScheduling).


} // end class def [Proposal].
