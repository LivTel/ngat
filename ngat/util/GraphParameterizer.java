package ngat.util;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;


/**
 * An interactive graphic panel which allows a user (CTRL) to define the form 
 * of a Schedule weighting function. The user draws the curve on screen and the
 * parameters are obtained when the screen is dismissed. This should be called from
 * an appropriate Dialog which specifies the weighting function being modified and 
 * the range of values to use. The behaviour outside the specified range should also
 * be specified via the dialog. A CTRL_SetScheduleParams_Req object is generated by
 * the calling Client application to implement the changes at the Server.
 *
 * $Id: GraphParameterizer.java,v 1.1 2000-11-21 17:02:01 snf Exp $
 *
 */

public class GraphParameterizer extends JPanel {
   
    /** Graph range and white space on panel (user space). */
    protected float xLo,xHi,yLo,yHi, deltaX, deltaY;

    /** Points array */
    protected float xPts[], yPts[];
    /** Number of anchors defined */
    protected int nPts;
 
    protected int moveAnchor;
    protected int mode;
    protected int level;
    
    /** Maximum no. of anchors allowed */
    public static final int MAX_PTS = 100;

    public static final int ADD_NODE = 1;
    public static final int MOVE_NODE_START = 2;
    public static final int MOVE_NODE_DRAG = 3;

    public GraphParameterizer(int maxPoints, float x1, float x2, float y1, float y2) {
	super(true);
	xLo = x1;
	xHi = x2;
	yLo = y1;
	yHi = y2;
	
	deltaX = 20.0F;
	deltaY = 20.0F;
	
	mode = ADD_NODE;

	level = 1;
	moveAnchor = 999;
	nPts = 0;
	xPts = new float[maxPoints];
	yPts = new float[maxPoints];
	
	setBackground(Color.white);
	
	addMouseListener(new MouseHandler());
	addMouseMotionListener(new MotionHandler());
    }

    /** Adds an anchor to the curve */
    public void putPoint(float x, float y) {
	xPts[nPts] = x;
	yPts[nPts] = y;
	nPts++;
	repaint();
    }
    
    /** Sets the drawing mode, called by GraphParameterFrame */
    public void setMode(int mode) { this.mode = mode;}

    /** Get the X axis lower bound. */
    public float getXLo() { return xLo; }

    /** Get the X axis upper bound. */
    public float getXHi() { return xHi; }

    /** Get the Y axis lower bound. */
    public float getYLo() { return yLo; }

    /** Get the Y axis upper bound. */
    public float getYHi() { return yHi; }


    /** Translates x from user to screen coordinates */
    public float getScreenX(float x) {
	float xScale = (getSize().width - 2*deltaX)/(xHi - xLo);
	float xOffset = deltaX - xLo*xScale;
	return x*xScale + xOffset;
    }
    
    /** Translates y from user to screen coordinates */
    public float getScreenY(float y) {
	float yScale = (getSize().height - 2*deltaY)/(yHi - yLo);
	float yOffset = yHi*yScale +deltaY;
	return yOffset - y*yScale;
    }
    
    /** Translates x from screen to user coordinates */
    public float getUserX(float x) {
	float xScale = (getSize().width - 2*deltaX)/(xHi - xLo);
	float xOffset = deltaX - xLo*xScale;
	return (x - xOffset)/xScale;
    }
    
    /** Translates y from screen to user coordinates */
    public float getUserY(float y) {
	float yScale = (getSize().height - 2*deltaY)/(yHi - yLo);
	float yOffset = yHi*yScale +deltaY;
	return (yOffset - y)/yScale;
    }
    
    /** Compute the positions of the x-axis tick marks and draw */
    protected void drawXTicks(Graphics g) {
	int nTicks = 0;
	int xTickPwr = (int)(Math.log((double)(xHi - xLo))/Math.log(10));
	float xTickInt = (float)Math.pow(10, xTickPwr);
	int m1 = (int)((float)(xLo/xTickInt) + 1);
	int m2 = (int)((float)(xHi/xTickInt));
	nTicks = m2 - m1 + 1;
    
	for (int i = m1; i <= m2; i++) {
	    int xLabel = (int)(i * xTickInt);
	    int xScreen = (int)getScreenX((float)xLabel);
	    int yScreen = (int)getScreenY(yLo);
	    g.drawLine(xScreen, yScreen, xScreen, yScreen + 5);
	    g.drawString("" + xLabel, xScreen - 5, yScreen + 15);
	}
    }
    
    /** Compute the positions of the y-axis tick marks and draw */
    protected void drawYTicks(Graphics g) {
	int nTicks = 0;
	int yTickPwr = (int)(Math.log((double)(yHi - yLo))/Math.log(10));
	float yTickInt = (float)Math.pow(10, yTickPwr);
	int m1 = (int)(yLo/yTickInt + 1);
	int m2 = (int)(yHi/yTickInt);
	nTicks = m2 - m1 + 1;
	
	for (int i = m1; i <= m2; i++) {
	    int yLabel = (int)(i * yTickInt);
	    int yScreen = (int)getScreenY((float)yLabel);
	    int xScreen = (int)getScreenX(xLo);
	    g.drawLine(xScreen, yScreen, xScreen - 5, yScreen);
	    g.drawString("" + yLabel, xScreen - 15, yScreen);
	}
    }
    
    /** Draw the axes. */
    protected void drawAxes(Graphics g) {
	int  x1 = (int)getScreenX(xLo);
	int  x2 = (int)getScreenX(xHi);
	int  y1 = (int)getScreenY(yLo);
	int  y2 = (int)getScreenY(yHi);
	
	g.drawLine(x1, y1, x2, y1);
	g.drawLine(x2, y1, x2, y2);
	g.drawLine(x1, y1, x1, y2);
	g.drawLine(x1, y2, x2, y2);
	
    }
    
    /** Draw the anchor points and join together with a spline */
    public void paint(Graphics g) {
	super.paint(g);

	drawAxes(g);
	drawXTicks(g);
	drawYTicks(g);
	
	g.setColor(Color.magenta);
		
	int x1 = (int)getScreenX(xPts[0]);
	int y1 = (int)getScreenY(yPts[0]);
	int x2 = 0;
	int y2 = 0;
	g.fillRect(x1-5, y1-5, 12, 12);

	for (int i = 1; i < nPts; i++) {				
	    x2 = (int)getScreenX(xPts[i]);
	    y2 = (int)getScreenY(yPts[i]);
	    g.fillRect(x2-5,y2-5,10,10);
	    g.drawLine(x1,y1, x2,y2);
	    x1 = x2;
	    y1 = y2;
	}
	g.fillRect(x2-5,y2-5,12,12);
	g.setColor(Color.black);
	
    }
    
    public void update(Graphics g) {
	paint(g);
    }

    /** Locate the anchor nearest the cursor. */
    public int findAnchorNearest(float x, float y) {
	float minDist = 9999.0f;// watch this !
	int anchor = -1;
	for (int i = 0; i < nPts; i++) {
	    float dist = (float)(Math.abs(xPts[i] - x) + Math.abs(yPts[i] - y));
	    if (dist < minDist) {
		minDist = dist;
		anchor = i;
	    }
	}
	return anchor;
    }
    
    /** Sort the anchors into x-order - they may have been messed about by user. 
     * A basic bubble-sort, easily fast enough.*/
    protected void sortAnchors() {
	int count;
	float tempX;
	float tempY;
	while (true){
	    count = 0;
	    for (int i = 1; i < nPts; i++) {
		if (xPts[i-1] > xPts[i]) {
		    tempX = xPts[i-1];
		    tempY = yPts[i-1];
		    xPts[i-1] = xPts[i];
		    yPts[i-1] = yPts[i];
		    xPts[i] = tempX;
		    yPts[i] = tempY;
		    count++;
		}
	    }
	    if (count == 0) break;
	}

    }

    /** Obtain the x-parameter values for the calling dialog */
    public float[] getXParameters() {
	float[] xF = new float[nPts];
	for (int i = 0; i < nPts; i++) {
	    xF[i] = (float)xPts[i];
	}
	return xF;
    }

    /** Obtain the y-parameter values for the calling dialog */
    public float[] getYParameters() {
	float[] yF = new float[nPts];
	for (int i = 0; i < nPts; i++) {
	    yF[i] = (float)yPts[i];
	}
	return yF;
    }
    

    // inner class to handle mouse events on the canvas.

    /** Handles mouse events on the drawing canvas 
     * - Adding anchor points.
     * - Deleting anchor points.
     */
    class MouseHandler extends MouseAdapter {

        public void mouseReleased(MouseEvent mev) {
  
	    sortAnchors();
	    repaint();
	 
        }  // (mouseReleased)
	
        public void mousePressed(MouseEvent mev) {

            int x = (int)mev.getX();
            int y = (int)mev.getY();
	    
            if (checkPopup(mev)) {return;}  // display popup and exit.
	    
            // convert to canvas coords.

            float mx = getUserX(x);
            float my = getUserY(y);

            if (mode == ADD_NODE) {                  // add a new Node.

                putPoint(mx, my);
                repaint();

            } else if (mode == MOVE_NODE_START) {   // id node to move.

                moveAnchor = findAnchorNearest(mx, my);
                mode = MOVE_NODE_DRAG;
           
            }

        }  // (mousePressed)

        protected boolean checkPopup(MouseEvent mev) {
            if (mev.isPopupTrigger()) {
                // temp ## replace with popup behaviour.
                // id the Node, Link etc then  e.g.
                // popup = SimUtilities.createNetworkNodeContextMenu();
                // popup.addActionListener(new PopupHandler(!node));
                // popup.show(this,mev.getX(),mev.getY())
                return true;
            }
            return false;
        }  // (checkPopup)


    }  // inner class def [MouseHandler]


    /** Handles mouse movement events on the canvas.
     * - Dragging anchor points
     * - Changing drag anchor. */
    class MotionHandler extends MouseMotionAdapter {

        // ## need to use mouseMoved() to deal with change of selection.

	public void mouseMoved(MouseEvent mev) {
	    
	    int x = (int)mev.getX();
            int y = (int)mev.getY();

            // convert to canvas coords.

            float mx = getUserX(x);
            float my = getUserY(y);
	    
	    if (mode == MOVE_NODE_DRAG) {
		// allow the drag anchor to change next mousePress().
		mode = MOVE_NODE_START;
	    }
	}

        public void mouseDragged(MouseEvent mev) {

            int x = (int)mev.getX();
            int y = (int)mev.getY();

            // convert to canvas coords.

            float mx = getUserX(x);
            float my = getUserY(y);

            if (mode == MOVE_NODE_DRAG) {
		if (moveAnchor != 0 && moveAnchor != nPts-1) {
		    // dont allow end anchors to shift in x-axis!
		    xPts[moveAnchor] = mx;
		}
                yPts[moveAnchor] = my;
		sortAnchors();
                repaint();
            }

        }  // (mouseDragged)

    }  // inner class def [MotionHandler]


}

/** $Log: not supported by cvs2svn $ */




